//
// ASCoDT - Advanced Scientific Computing Development Toolkit
//
// This file was generated by ASCoDT's simplified SIDL compiler.
//
// Authors: Tobias Weinzierl, Atanas Atanasov   
//
package cca.cfd;


public class NSSolverDispatcher implements NSSolver {

  protected java.util.Set<NSSolver>  _destinations;
  
  public NSSolverDispatcher() {
    _destinations = java.util.Collections.synchronizedSet(new java.util.HashSet<NSSolver>());
  }
  
  public long getReference(){
    return 0;
  }
  
  
  public void setReference(long ref){
  }
  /**
   * Connect a uses port.
   *
   * @throw If already connected to another port.
   * @see Operation with name of any implementing component 
   */
  public void connect(NSSolver  port) throws de.tum.ascodt.utils.exceptions.ASCoDTException {
    if (_destinations==null) {
      throw new de.tum.ascodt.utils.exceptions.ASCoDTException( getClass().getName(), "connect(...)", "port already was connected", null );
    }
    _destinations.add(port);
  }
    
  /**
   * Disconnect a port.
   * 
   * @throw If already not connected to type port.
   * @see Operation with name of any implementing component 
   */
  public void disconnect(NSSolver  port) throws de.tum.ascodt.utils.exceptions.ASCoDTException {
    if (_destinations==null) {
      throw new de.tum.ascodt.utils.exceptions.ASCoDTException( getClass().getName(), "disconnect(...)", "tried to disconnect port that was not connected before", null );
    }
     
    if (!_destinations.contains(port)) {
      throw new de.tum.ascodt.utils.exceptions.ASCoDTException( getClass().getName(), "disconnect(...)", "tried to disconnect port from port that was not connected before", null );
    }
    _destinations.remove(port);
  }
  
  public boolean isConnected(){
     return !_destinations.isEmpty();
  }
  
  public void setup(final String inputScenario) {
    for(NSSolver port: _destinations)
      port.setup(inputScenario);
  }
  
  public void setupParallel(final String inputScenario) {
    for(NSSolver port: _destinations)
      port.setupParallel(inputScenario);
  }
  
  public void setupForIntegerEnums(final String inputScenario) {
    for(NSSolver port: _destinations){
      
      port.setup(inputScenario);
      
    }
  }
  public void setupCommForLBRegion(final int startOfRegion[],final int endOfRegion[],final String commids[]) {
    for(NSSolver port: _destinations)
      port.setupCommForLBRegion(startOfRegion,endOfRegion,commids);
  }
  
  public void setupCommForLBRegionParallel(final int startOfRegion[],final int endOfRegion[],final String commids[]) {
    for(NSSolver port: _destinations)
      port.setupCommForLBRegionParallel(startOfRegion,endOfRegion,commids);
  }
  
  public void setupCommForLBRegionForIntegerEnums(final int startOfRegion[],final int endOfRegion[],final String commids[]) {
    for(NSSolver port: _destinations){
      
      port.setupCommForLBRegion(startOfRegion,endOfRegion,commids);
      
    }
  }
  public void solve() {
    for(NSSolver port: _destinations)
      port.solve();
  }
  
  public void solveParallel() {
    for(NSSolver port: _destinations)
      port.solveParallel();
  }
  
  public void solveForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.solve();
      
    }
  }
  public void solveOneTimestepPhaseOne() {
    for(NSSolver port: _destinations)
      port.solveOneTimestepPhaseOne();
  }
  
  public void solveOneTimestepPhaseOneParallel() {
    for(NSSolver port: _destinations)
      port.solveOneTimestepPhaseOneParallel();
  }
  
  public void solveOneTimestepPhaseOneForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.solveOneTimestepPhaseOne();
      
    }
  }
  public void solveOneTimestepPhaseTwo() {
    for(NSSolver port: _destinations)
      port.solveOneTimestepPhaseTwo();
  }
  
  public void solveOneTimestepPhaseTwoParallel() {
    for(NSSolver port: _destinations)
      port.solveOneTimestepPhaseTwoParallel();
  }
  
  public void solveOneTimestepPhaseTwoForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.solveOneTimestepPhaseTwo();
      
    }
  }
  public void setVelocities(final double velocitiesX[],final double velocitiesY[],final double velocitiesZ[]) {
    for(NSSolver port: _destinations)
      port.setVelocities(velocitiesX,velocitiesY,velocitiesZ);
  }
  
  public void setVelocitiesParallel(final double velocitiesX[],final double velocitiesY[],final double velocitiesZ[]) {
    for(NSSolver port: _destinations)
      port.setVelocitiesParallel(velocitiesX,velocitiesY,velocitiesZ);
  }
  
  public void setVelocitiesForIntegerEnums(final double velocitiesX[],final double velocitiesY[],final double velocitiesZ[]) {
    for(NSSolver port: _destinations){
      
      port.setVelocities(velocitiesX,velocitiesY,velocitiesZ);
      
    }
  }
  public void printNSPressure() {
    for(NSSolver port: _destinations)
      port.printNSPressure();
  }
  
  public void printNSPressureParallel() {
    for(NSSolver port: _destinations)
      port.printNSPressureParallel();
  }
  
  public void printNSPressureForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.printNSPressure();
      
    }
  }
  public void printNSProfiles() {
    for(NSSolver port: _destinations)
      port.printNSProfiles();
  }
  
  public void printNSProfilesParallel() {
    for(NSSolver port: _destinations)
      port.printNSProfilesParallel();
  }
  
  public void printNSProfilesForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.printNSProfiles();
      
    }
  }
  public void closeNSProfiles() {
    for(NSSolver port: _destinations)
      port.closeNSProfiles();
  }
  
  public void closeNSProfilesParallel() {
    for(NSSolver port: _destinations)
      port.closeNSProfilesParallel();
  }
  
  public void closeNSProfilesForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.closeNSProfiles();
      
    }
  }
  public void iterateBoundary() {
    for(NSSolver port: _destinations)
      port.iterateBoundary();
  }
  
  public void iterateBoundaryParallel() {
    for(NSSolver port: _destinations)
      port.iterateBoundaryParallel();
  }
  
  public void iterateBoundaryForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.iterateBoundary();
      
    }
  }
  public void iterateInner() {
    for(NSSolver port: _destinations)
      port.iterateInner();
  }
  
  public void iterateInnerParallel() {
    for(NSSolver port: _destinations)
      port.iterateInnerParallel();
  }
  
  public void iterateInnerForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.iterateInner();
      
    }
  }
  public void forwardVelocities(int keys[],int offsets[],int flips[],double values[],int componentSize[],int ackn[]) {
    for(NSSolver port: _destinations)
      port.forwardVelocities(keys,offsets,flips,values,componentSize,ackn);
  }
  
  public void forwardVelocitiesParallel(int keys[],int offsets[],int flips[],double values[],int componentSize[],int ackn[]) {
    for(NSSolver port: _destinations)
      port.forwardVelocitiesParallel(keys,offsets,flips,values,componentSize,ackn);
  }
  
  public void forwardVelocitiesForIntegerEnums(int keys[],int offsets[],int flips[],double values[],int componentSize[],int ackn[]) {
    for(NSSolver port: _destinations){
      
      port.forwardVelocities(keys,offsets,flips,values,componentSize,ackn);
      
    }
  }
  public void plot() {
    for(NSSolver port: _destinations)
      port.plot();
  }
  
  public void plotParallel() {
    for(NSSolver port: _destinations)
      port.plotParallel();
  }
  
  public void plotForIntegerEnums() {
    for(NSSolver port: _destinations){
      
      port.plot();
      
    }
  }
  public void syncr(int value[]) {
    for(NSSolver port: _destinations)
      port.syncr(value);
  }
  
  public void syncrParallel(int value[]) {
    for(NSSolver port: _destinations)
      port.syncrParallel(value);
  }
  
  public void syncrForIntegerEnums(int value[]) {
    for(NSSolver port: _destinations){
      
      port.syncr(value);
      
    }
  }
  
//  public void lock() {
//    if (_destination!=null) {
//      _destination.lock();
//    }
//  }
 
//  public void unlock() {
//    if (_destination!=null) {
//      _destination.unlock();
//    }
//  }
  
}
 


