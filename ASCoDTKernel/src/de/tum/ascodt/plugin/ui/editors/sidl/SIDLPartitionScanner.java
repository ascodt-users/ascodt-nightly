package de.tum.ascodt.plugin.ui.editors.sidl;


import java.util.ArrayList;
import java.util.List;

import org.eclipse.jface.text.rules.EndOfLineRule;
import org.eclipse.jface.text.rules.ICharacterScanner;
import org.eclipse.jface.text.rules.IPredicateRule;
import org.eclipse.jface.text.rules.IRule;
import org.eclipse.jface.text.rules.IToken;
import org.eclipse.jface.text.rules.IWordDetector;
import org.eclipse.jface.text.rules.MultiLineRule;
import org.eclipse.jface.text.rules.RuleBasedPartitionScanner;
import org.eclipse.jface.text.rules.SingleLineRule;
import org.eclipse.jface.text.rules.Token;
import org.eclipse.jface.text.rules.WordRule;


/**
 * This class defines the different partitions in a sidl document
 * 
 * @author atanasoa
 * 
 */
public class SIDLPartitionScanner extends RuleBasedPartitionScanner {

  /**
   * Detector for empty comments.
   */
  static class EmptyCommentDetector implements IWordDetector {

    /*
     * (non-Javadoc)
     * Method declared on IWordDetector
     */
    @Override
    public boolean isWordPart(char c) {
      return c == '*' || c == '/';
    }

    /*
     * (non-Javadoc)
     * Method declared on IWordDetector
     */
    @Override
    public boolean isWordStart(char c) {
      return c == '/';
    }
  }

  /**
	 *
	 */
  static class WordPredicateRule extends WordRule implements IPredicateRule {

    private IToken fSuccessToken;

    public WordPredicateRule(IToken successToken) {
      super(new EmptyCommentDetector());
      fSuccessToken = successToken;
      addWord("/**/", fSuccessToken); //$NON-NLS-1$
    }

    /*
     * @see
     * org.eclipse.jface.text.rules.IPredicateRule#evaluate(ICharacterScanner,
     * boolean)
     */
    @Override
    public IToken evaluate(ICharacterScanner scanner, boolean resume) {
      return super.evaluate(scanner);
    }

    /*
     * @see org.eclipse.jface.text.rules.IPredicateRule#getSuccessToken()
     */
    @Override
    public IToken getSuccessToken() {
      return fSuccessToken;
    }
  }

  public final static String SIDL_MULTILINE_COMMENT = "__sidl_multiline_comment";
  public final static String SIDL_DOC = "__sidl_doc";

  public final static String SIDL_LINE_COMMENT = "__sidl_line_comment";

  public final static String[] SIDL_PARTITION_TYPES = new String[] {
    SIDL_LINE_COMMENT, SIDL_MULTILINE_COMMENT, SIDL_DOC};

  /**
   * Creates the partitioner and sets up the appropriate rules.
   */
  public SIDLPartitionScanner() {
    super();

    IToken m_comment = new Token(SIDL_MULTILINE_COMMENT);
    IToken comment = new Token(SIDL_LINE_COMMENT);
    List<IRule> rules = new ArrayList<IRule>();

    // Add rule for single line comments.
    rules.add(new EndOfLineRule("//", Token.UNDEFINED)); //$NON-NLS-1$

    // Add rule for strings and character constants.
    rules.add(new SingleLineRule("\"", "\"", Token.UNDEFINED, '\\')); //$NON-NLS-2$ //$NON-NLS-1$
    rules.add(new SingleLineRule("'", "'", Token.UNDEFINED, '\\')); //$NON-NLS-2$ //$NON-NLS-1$

    // Add special case word rule.
    rules.add(new WordPredicateRule(comment));

    // Add rules for multi-line comments and javadoc.
    rules.add(new MultiLineRule("/**", "*/", m_comment, (char)0, true)); //$NON-NLS-1$ //$NON-NLS-2$
    rules.add(new MultiLineRule("/*", "*/", m_comment, (char)0, true)); //$NON-NLS-1$ //$NON-NLS-2$
    rules.add(new SingleLineRule("//", "", comment, (char)0, true)); //$NON-NLS-1$ //$NON-NLS-2$

    IPredicateRule[] result = new IPredicateRule[rules.size()];
    rules.toArray(result);
    setPredicateRules(result);
  }
}
